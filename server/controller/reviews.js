const reviewsRouter = require('express').Router();
const Review = require('../model/review');
const sequelize = require('../sql-connection')

const serverErrorReponse = {
  statusCode: 400,
  body: JSON.stringify({
    message: 'Server not responding',
  }),
};

reviewsRouter.get('/', async (req, res) => {
// TODO: figure out how to use query params to get the necessary filters
// TODO: Parse the filters into the sql query statement
// TODO: Decide what is the limit that we will send to frontend each time
// TODO: How to keep track of the reviews that we have sent and the ones to send
    // Something like first 10, then the next time the same user requests, we need to send the next 10
    const oneReview = Review.findOne({
      where:{
        asin: "B000FA64PA"
      }
    }).then((result) => {
      console.log(result)
      res.send(result)
    }).catch((error) => {
      console.log('shit hit the fan')
      res.send(error)
    });

})

// RETRIEVE SPECIFIC REVIEW
reviewsRouter.get('/:reviewID', (req, res) => {
  
  // Ensure that the reviewID is an int
  if(parseInt(req.param.reviewID)!= NaN){
    
    // Conduct SELECT sql query to retrieve the review based on reviewID
      const oneReview = Review.findOne({
        where:{
          id: req.params.reviewID
        }
      }).then((result) => {
        console.log(result)
        res.send(result)
      }).catch((error) => {
        console.log('shit hit the fan')
        res.send(badQueryMsgGen(error))
      });
    }
  else{
    res.send(badRequestMsgGen('reviewID must be integer'))
  }

})

// RETRIEVE REVIEWS BASED ON BOOKID
reviewsRouter.post('/filterBook/:bookID', (req, res) => {
  // Frontend is to let us know which reviews we are to send. This populates the start and amount fields in the reqeuest body
  console.log("BookID stuff")
  // console.log(req.body)
  try{
    // Check if the offset values make sense
    checkOffsets(req.body.start, req.body.amount)
    
    // Raw query constructed for sequelize query
    var sqlQuery = 'SELECT * FROM kindle_Review_Data WHERE asin = "'+req.params.bookID+'" LIMIT '+req.body.start+','+req.body.amount
    console.log(req.body)
    //  Conduct SELECT sql query to retrieve all reviews for specific
      const allBookReviews = sequelize.query(sqlQuery)
      .then((result) => {
        console.log(result[0])
        res.send(result[0])
      }).catch((error) => {
        console.log('shit hit the fan')
        console.log(error)
        res.send(badQueryMsgGen(error.message))
      })

      // const allBookReviews = Review.findAll({
      //   subQuery: false,
      //   where:{
      //     asin: req.params.bookID
      //   },
      //   offset:req.body.start,
      //   limit: req.body.amount,
      // }).then((result) => {
      //   console.log(result)
      //   res.send(result)
      // }).catch((error) => {
      //   console.log('shit hit the fan')
      //   console.log(error)
      //   res.send(badQueryMsgGen(error.message))
      // });
    }
    catch(err){
      console.log('Some error')
      console.log(err)
      res.send(badRequestMsgGen(err))
    }
  })

// curl -d "asin=B0324714&helpful=[0,0]&overall=3&reviewText=NotThatBadIGuess&reviewTime=201012&reviewerID=J05EJ011N50N&unixReviewTime=1234567890&reviewerName=JoseJohnson" -X POST http://localhost:5000/review/addReview
// id = 982620
// ADD A NEW REVIEW
reviewsRouter.post('/addReview', (req, res) => {
    // Generate UID for new review. 
      // UID is auto generated by Sequelize
      console.log("add review")
    // Conduct the INSERT sql query to add review to database
    const addReview = Review.create({
      asin: req.body.asin,
      helpful: req.body.helpful,
      overall: req.body.overall,
      reviewText: req.body.reviewText,
      reviewTime: req.body.reviewTime,
      reviewerID: req.body.reviewerID,
      reviewerName: req.body.reviewerName,
      unixReviewTime: req.body.unixReviewTime
    }).then((result) => {
      console.log(result)
      res.send(result)
    }).catch((error) => {
      console.log('shit hit the fan')
      console.log(error)
      res.send(badQueryMsgGen(error.message))
    })

  })

// DELETE REIVEW BASED ON REIVEWID
//curl -X DELETE http://localhost:5000/review/deleteReview/982621
reviewsRouter.delete('/deleteReview/:reviewID', (req, res) => {
    // Delete review based on reviewID in the URL parameters
    console.log("Delete review")
    const deleteReview = Review.destroy({
      where:{
        id: req.params.reviewID
      }
    }).then((result) => {
      console.log(result)
      // console.log(result)
      res.send('Delete successsful')
    }).catch((error) => {
      console.log('shit hit the fan')
      console.log(error)
      res.send(badQueryMsgGen(error.message))
    })

  })

// UPDATE A SPECIFIC REVIEW
//curl -d "overall=5&reviewText=OkayLaIChangethetext" -X POST http://localhost:5000/review/updateReview/982623
reviewsRouter.post('/updateReview/:reviewID', (req, res) => {

    console.log("Update review")
    const deleteReview = Review.update({
      overall: req.body.overall,
      reviewText: req.body.reviewText,
    },{
      where:{
        id: req.params.reviewID
      }
    }).then((result) => {
      console.log(result)
      // console.log(result)
      res.send('Update successsful')
    }).catch((error) => {
      console.log('shit hit the fan')
      console.log(error)
      res.send(badQueryMsgGen(error.message))
    })

  })

// RETRIEVE REVIEWS BASED ON PROVIDED FILTERS
reviewsRouter.get('/review', (req, res) => {
    // TODO: figure out how to use query params to get the necessary filters
    // TODO: Parse the filters into the sql query statement
    // TODO: Decide what is the limit that we will send to frontend each time
    // TODO: How to keep track of the reviews that we have sent and the ones to send
        // Something like first 10, then the next time the same user requests, we need to send the next 10
    res.send('Hello World!')
  })

  function badQueryMsgGen(message){
    return badRequestErrorReponse = {
      statusCode: 500,
      body: JSON.stringify({
        message: message,
      }),
    };
  }

  function badRequestMsgGen(message){
    return badRequestErrorReponse = {
      statusCode: 404,
      headers: {
        'Access-Control-Allow-Origin': '*', // Required for Cors support to work
        'Content-Type': 'application/json; charset=utf-8',
      },
      body: JSON.stringify({
        message: message,
      }),
    };
  }

  function checkOffsets(start,amount){
    try{
      var numStart = parseInt(start)
      var numAmount = parseInt(amount)
      if(numAmount==NaN || numStart==NaN){
        throw 'Offset limits parsed are not numbers'
      }
      else if (numStart<0){
        throw 'Start parameter invalid. Query Limit error'
      }
    }
    catch (err){
      throw err
    }
  }

  function reviewInfoCheck(detailsJSON){
    return true
  }

module.exports = reviewsRouter;